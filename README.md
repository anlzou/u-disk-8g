<!--
 * @Date        : 2020-05-05 09:37:15
 * @LastEditors : anlzou
 * @Github      : https://github.com/anlzou
 * @LastEditTime: 2020-05-05 09:48:55
 * @FilePath    : \u-disk-8g\README.md
 * @Describe    : 
 -->
 # u-disk-8g
 学科竞赛project

# 题目
...

# 说明
为了兼容其他语言数值位宽限制，同时优化算法。决定用数组模拟超大数值。Python没有限制长整数数值的大小，但实际上由于内存有限，所以我们使用的长整数数值不可能无限大。

## 一、数组存放超大值
首先解决排列组合计算产生的超大值，用数组存放这个值，数组的第0位不取，数组第1位对应超大值的个位，数组第2位对应超大值的十位，数组第3位对应超大值的百位，以此类推。用数组Data保存，初始化：Data[i] = j{i = 0,1,2…N；j = 0,1,0,0…0}

## 二、人工模拟计算排列组合
排列组合的计算方式，人工的方式为先约分只剩下分母，后相乘。用算法模拟。
## 程序算法实现：
### 1、化简
分母的化简阶乘为，n * (n-1) * (n-2) * … * (max(k,(n-k))+1)，从大到小排列；
分子的化简阶乘为，min(k,(n-k)) * (min(k,(n-k))-1) * … * 1，从大到小排列。
把分母的化简阶乘每个乘数放入分母数组data_max[i] = j；{i = 1,2…min(k,(n-k))；j = n,(n-1)…max(k,(n-k)+1)}；
把分子的化简阶乘每个乘数放入分子数组data_min[i] = j；{i = 1,2…min(k,(n-k))；j = min(k,n-k),(min(k,(n-k))-1)…1}。
### 2、约分
分母与分子进行约分处理，需要借助一个存放公约数为基数的base数组，base数组为，取第0位，且置为2，base[i] = j；{i = 0,1…min(k,(n-k))；j = 2,3,5,7…min(k,(n-k))}。

#### 分子数组嵌套分母数组作循环：
- 情况一：如果分母可以被分子整除，分母取分母除以分子的商，分子置为1
- 情况二：分母，分子存在公约数，分母取分母除以公约数的商，分子取分子除以公约数的商
- 其他情况继续循环。
- 处理结果：分母剩下约分后的值，分子全部为1，约分成功。

### 3、相乘
#### 循环分母数组：
分母数组乘Data每位数组的值放入Data数组，Data数组进位处理。
#### 例：分母为：50 33 98
- 第一次循环：乘：Data[1] = Data[1]*data_max[1] = 1*50 = 50进位：Data[2] = Data[2]+Data[1]//10 = 0+5 = 5，Data[1] = Data[1]%10 = 0
- 第二次循环：乘：Data[1] = Data[1]*data_max[2] = 0*33 = 0，Data[2] = Data[2]*data_max[2] = 5*33 = 165，进位：Data[2] = Data[2]+Data[1]//10 = 165+0 = 165，Data[1] = Data[1]%10 = 0，Data[3] = Data[3]+Data[2]//10 = 0+16 = 16，Data[2] = Data[2]%10 = 165%10 = 5
- 第三次循环：乘：Data[1] = Data[1]*data_max[3] = 0，Data[2] = Data[2]data_max[3] = 5*98 = 490，Data[3] = Data[3]*data_max[3] = 1568，进位：Data[2] = Data[2]+Data[1]//10 = 490+0 = 490，Data[1] = Data[1]%10 = 0，Data[3] = Data[3]+Data[2]//10 = 1568+49 = 1617，Data[2] = Data[2]%10 = 490%10 = 0，Data[4] = Data[4]+Data[3]//10 = 0+161 = 161，Data[3] = Data[3]%10 = 1617%10 = 7

### 4、处理Data数组
Data的最高位未进位处理，把最高位转换成str类型，把str类型转换成数组，数组逆置，把逆置的数组衔接到Data数组。
把Data数组转换成一个值放入head，意义：head = C(n,k)。排列组合计算完成。
## 三、计算分布列
p^k * (1-p)^(n-k)计算的值放入tail，head*tail的值既为分布列的值。计算完成。

## 四、结果
![resource\image\image001.png](resource\image\image001.png)
![resource\image\image002.png](resource\image\image002.png)

# prize
u-disk-8g